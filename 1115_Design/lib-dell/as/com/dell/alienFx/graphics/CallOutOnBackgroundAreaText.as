/** * Created with IntelliJ IDEA. * User: Jerry Orta * http://www.digitalproductionart.com/ * jerryorta@gmail.com * * Date: 10/29/12 * Time: 2:35 PM**//**import com.greensock.*;import com.greensock.easing.*;//Schwab Bubbleimport com.schwab.graphics.*;*  rectWidth:value		//Rectangle width of bubble*  rectHEIGHT:value		//Rectangle height of bubble*  pointWIDTH:value		//Point width of bubble*  pointHEIGHT:value	//Point height of bubble*  pointX				//pointX position of bubble point from left margin of rectangle*  radiusRECT			//Radius of the rectangular corner points*  radiusPOINT			//Radius of the bubble point corner points*  bubbleCOLOR			//Color fill of bubble, can be "0x009900" OR 0x009900 -- no string*  fillALPHA			//Alpha of color fill*  borderCOLOR			//Color of border*  borderWEIGHT			//Weight of border*  borderALPHA			//Alpha of border*  pointRIGHT			//Bubble points left -- true or falsevar bubble:Bubble = new Bubble({			rectWidth:200, 			rectHEIGHT:100, 			pointWIDTH:75, 			pointHEIGHT:100, 			pointX:75, 			radiusRECT:20, 			radiusPOINT:15, 			bubbleCOLOR:"0x009900", 			fillALPHA:1, 			borderCOLOR:"0x990000",			borderWEIGHT:2,			borderALPHA:1,			pointRIGHT:false,			translatePointTo:50});addChild(bubble);bubble.x = 20;bubble.y = 20;var bubble2:Bubble = new Bubble();addChild(bubble2);bubble2.x = 230;bubble2.y = 90;//bubble2.rectWidth = 200;//bubble2.pointRIGHT = false; TweenLite.to(bubble2, 4, {delay:2, x:"-100", rectWidth:"+100", radiusRECT:"+50", ease:Linear.easeNone});alignPointLeft get the value of the left base numberalignPointLeft get the value of the right base number*/package com.dell.alienFx.graphics {    import com.dpa.graphics.core.RoundPathHelper;    import com.dell.alienFx.SwatchAFX;    import flash.display.GradientType;    import flash.display.Sprite;    import flash.geom.Matrix;    import flash.geom.Point;import flash.filters.BitmapFilter;import flash.filters.BitmapFilterQuality;import flash.filters.GlowFilter;    public class CallOutOnBackgroundAreaText extends Sprite {		public var vars:Object; 				//Points of bubble		private var _rectWidth:Number;		//Width of rectangle		private var _rectHeight:Number;		//Height of rectangle		private var _radiusRect:Number;		//Radius of the rectangle corners        //COLOR		private var _fillColor:uint;		//Color fill of bubble		private var _fillAlpha:Number;		//Alpha of fill color		private var _borderColor:Number;		//Color of border		private var _borderWeight:Number;	//Weight of border		private var _borderAlpha:Number;		//Alpha of border        private var points:Array;        private var radii:Array;        //GRADIENT        private var _gradientColors:Array;        private var _gradienAlphas:Array;        private var _ratios:Array;        private var _matrixWidth:Number;        private var _matrixHeight:Number;        private var _matrixRotation:Number;        private var _matrixTx:Number;        private var _matrixTy:Number;        private var _strokeGradientColors:Array;        private var _strokeGrapdientAlphas:Array;        private var _strokeGradientRations:Array;        private var _strokeMatrixWidth:Number;        private var _strokeMatrixHeight:Number;        private var _strokeMatrixRotation:Number;        private var _strokeMatrixTx:Number;        private var _strokeMatrixTy:Number;        //STATE        private var _state:String = "off";				//Rounded corner Vectors		public function CallOutOnBackgroundAreaText(vars:Object = null) {					this.vars = (vars != null) ? vars : {};            //Dimensions			_rectWidth = (this.vars.width != null) ? this.vars.width : 240;			_rectHeight = (this.vars.height != null) ? this.vars.height : 95;            _radiusRect = (this.vars.radiusRect != null) ? this.vars.radiusRect : 5;            //Color            _fillColor = (this.vars.fillColor != null) ? this.vars.fillColor : 0xffffff;            _borderColor = (this.vars.borderColor != null) ? this.vars.borderColor : 0xffffff;            //Weight            _borderWeight = (this.vars.borderWeight != null) ? this.vars.borderWeight : 0;            //Alpha            _fillAlpha = (this.vars.fillAlpha != null) ? this.vars.fillAlpha : 1;            _borderAlpha = (this.vars.borderAlpha != null) ? this.vars.borderAlpha : 0;            //FILL            _gradientColors = vars.gradientColors;            _gradienAlphas = [1, 1];            _ratios=[40, 255];            _matrixWidth = _rectWidth;            _matrixHeight = _rectHeight;            _matrixRotation = 126;            _matrixTy = 0;            _matrixTx = 0;            //Stroke;            _strokeGradientColors = vars.strokeGradientColors;            _strokeGrapdientAlphas = [1, 1, 1, 1];            _strokeGradientRations = [0, 25,  210,255];            _strokeMatrixWidth = _rectWidth;            _strokeMatrixHeight = _rectHeight;            _strokeMatrixRotation = 45;            _strokeMatrixTx = 0;            _strokeMatrixTy = 0;            calculatePoints();		}						private function calculatePoints():void {//UPPER LEFT OF RECTANGLE            var bp1:Point = new Point(0, 0);            //UPPER RIGHT OF RECTANGLE            var bp2:Point = new Point(_rectWidth, 0);            //LOWER LEFT OF RECTANGLE            var bp3:Point = new Point(_rectWidth, _rectHeight);            //Lower Left of rectangle            var bp4:Point = new Point(0, _rectHeight);            points = [bp1, bp2, bp3, bp4];            radii = [_radiusRect, _radiusRect, _radiusRect, 0];			paint();            var glowFilter:BitmapFilter = getBitmapFilter();            filters = [ glowFilter ];		}						private function paint():void {			graphics.clear();            graphics.lineStyle(1);            var strokeMat:Matrix = new Matrix();            strokeMat.createGradientBox(_strokeMatrixWidth, _strokeMatrixHeight, _strokeMatrixRotation, _strokeMatrixTx, _strokeMatrixTy);            graphics.lineGradientStyle(GradientType.LINEAR, _strokeGradientColors, _strokeGrapdientAlphas, _strokeGradientRations, strokeMat );            var mat:Matrix = new Matrix();            mat.createGradientBox(_matrixWidth, _matrixHeight, _matrixRotation, _matrixTx, _matrixTy);//			graphics.beginFill(_fillColor,_fillAlpha);            graphics.beginGradientFill(GradientType.LINEAR,_gradientColors,_gradienAlphas,_ratios,mat);            RoundPathHelper.drawRoundPath({g:graphics, points:points, closePath:true, radii:radii});			graphics.endFill();		}        private function getBitmapFilter():BitmapFilter {            var color:Number = 0x25e9eb;            var alpha:Number = 0.15;            var blurX:Number = 35;            var blurY:Number = 35;            var strength:Number = 2;            var inner:Boolean = false;            var knockout:Boolean = false;            var quality:Number = BitmapFilterQuality.HIGH;            return new GlowFilter(color,                    alpha,                    blurX,                    blurY,                    strength,                    quality,                    inner,                    knockout);        }				public function set rectWidth(val:Number):void {			_rectWidth = val;			calculatePoints();		}				public function get rectWidth():Number {			return _rectWidth;		}				public function set rectHeight(val:Number):void {			_rectHeight = val;			calculatePoints();		}				public function get rectHeight():Number {			return _rectHeight;		}						public function set radiusRect(val:Number):void {			_radiusRect = val;			calculatePoints();		}				public function get radiusRect():Number {			return _radiusRect;		}				public function set fillColor(val:Number):void {			_fillColor = val;			calculatePoints();		}				public function get fillColor():Number {			return _fillColor;		}				public function set fillAlpha(val:Number):void {			_fillAlpha = val;			calculatePoints();		}				public function get fillAlpha():Number {			return _fillAlpha;		}				public function set borderColor(val:Number):void {			_borderColor = val;			calculatePoints();		}				public function get borderColor():Number {			return _borderColor;		}				public function set borderWeight(val:Number):void {			_borderWeight = val;			calculatePoints();		}				public function get borderWeight():Number {			return _borderWeight;		}				public function set borderAlpha(val:Number):void {			_borderAlpha = val;			calculatePoints();		}				public function get borderAlpha():Number {			return _borderAlpha;		}    }	}